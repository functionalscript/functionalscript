# Call-like instructions

Call-like bytecode instruction include following groups:

1. **calls into host functions** (standard language runtime "intrinsics", including operators);
2. **static calls into user-defined functions**;
3. **dynamic calls into user-defined functions**;
4. **other call-like instructions** (mentioned here thanks to similarities to above mentioned groups).

## 1. Calls into host functions

Each host function has a stable identification (e.g. a numeric id predefined within a given FS
release) and runtime metadata specifying among other things its number of parameters and whether or
not it returns a result.

The interpreter accesses metadata upon decoding the starting part of a call instruction. Knowing the
number of parameters and result presence flag, it continues decoding argument instructions filling
out an internal data structure best fit for the given host function. For example,

```js
const c = a + b
```

produces bytecode for calling host's implementation of operator plus, followed by slot
specifications for `a`, `b` and `c` at the caller stack frame. This allows to execute that built-in
function without overhead of copying `a`, `b` to the top of the stack and then copying the result
to the caller stack frame slot allocated for `c`.

A schema for a host function call looks like

<host call instruction> <predefined host function id> <predefined number of argument specifications>

&ndash regardless how many bits each part takes, we can exeperiment with different encodings,
including schemes with variable-length function id and argument specification parts. Note that
the number of arguments is predefined for each function id, so this kind of a call instruction
does not need to carry it.

## 2. Static calls into user-defined functions

In case when bytecode generator has complete information of a function being called, a reference
to that function is resolved at load time &ndash; in this case the call instruction identifies
the callee user-defined function by an integer key to the correspondent lookup table built at load
time.

A schema for a static call differs from the schema for a host function call in two aspects:

- The function id is not predefined; that number is generated by the parser and is backed with
a correspondent entry in one of metadata tables produced by the parser alongside with bytecode
instructions.

- The length of the sequence of argument specifications is specifed in the instruction (unlike
to that in host function calls that length is predefined for each function id). We can prepend
that number at the start of the list, or use a special value terminal argument specified
encoding at the end of the list.

<static call instruction> <runtime function id> <list of arguments with explicitly defined length>

## 3. Dynamic calls into user-defined functions

Sometimes the parser cannot determine the callee function object statically (at parse time). For
example, that function object gets retrieved as a property of an object by a dynamic lookup
(with property named not known at parse time but calculated at run time), or as an element of
an array, or as a result of another function call.

In this case the function object is identified by its location specification akin to to location-
based argument specifications. That specification is followed by argument specifications in
same way as in the static call instruction. In a way, we can consider the function object
specification as the first always-existing argument specification, but it makes sense to separate
it out and then have exactly same argument list specification for zero or more arguments.

<dynamic call instruction> <function object location specification> <list of argument specifications
with explicitly defined length>

## 4. Other call-like instructions

## 5. Argument specifications


