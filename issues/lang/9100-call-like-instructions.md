# Call-like instructions

Call-like bytecode instruction include following groups:

1. **calls into host functions** (standard language runtime "intrinsics", including operators);
2. **static calls into user-defined functions**;
3. **dynamic calls into user-defined functions**;
4. **other call-like instructions** (mentioned here thanks to similarities to above mentioned groups).

## 1. Calls into host functions

Each host function has a stable identification (e.g. a numeric id predefined within a given FS
release) and runtime metadata specifying among other things its number of parameters and whether or
not it returns a result.

The interpreter accesses metadata upon decoding the starting part of a call instruction. Knowing the
number of parameters and result presence flag, it continues decoding argument instructions filling
out an internal data structure best fit for the given host function. For example,

```js
const c = a + b
```

produces bytecode for calling host's implementation of operator plus, followed by slot
descriptors for `a`, `b` and `c` at the caller stack frame. This allows to execute that built-in
function without overhead of copying `a`, `b` to the top of the stack and then copying the result
to the caller stack frame slot allocated for `c`.

A schema for a host function call looks like

`<host call instruction> <predefined host function id> <predefined number of argument descriptors>`

&ndash regardless how many bits each part takes, we can exeperiment with different encodings,
including schemes with variable-length function id and argument descriptor parts. Note that
the number of arguments is predefined for each function id, so this kind of a call instruction
does not need to carry it.

## 2. Static calls into user-defined functions

In case when bytecode generator has complete information of a function being called, a reference
to that function is resolved at load time &ndash; in this case the call instruction identifies
the callee user-defined function by an integer key to the correspondent lookup table built at load
time.

A schema for a static call differs from the schema for a host function call in two aspects:

- The function id is not predefined; that number is generated by the parser and is backed with
a correspondent entry in one of metadata tables produced by the parser alongside with bytecode
instructions.

- The length of the sequence of argument descriptors is specifed in the instruction (unlike
to that in host function calls that length is predefined for each function id). We can prepend
that number at the start of the list, or use a special value terminal argument specified
encoding at the end of the list.

`<static call instruction> <runtime function id> <list of arguments with explicitly defined length>`

## 3. Dynamic calls into user-defined functions

Sometimes the parser cannot determine the callee function object statically (at parse time). For
example, that function object gets retrieved as a property of an object by a dynamic lookup
(with property named not known at parse time but calculated at run time), or as an element of
an array, or as a result of another function call.

In this case the function object is identified by its location descriptor akin to to location-
based argument descriptors. That descriptor is followed by argument descriptors in
same way as in the static call instruction. In a way, we can consider the function object
descriptor as the first always-existing argument descriptor, but it makes sense to separate
it out and then have exactly same argument list descriptor for zero or more arguments.

`<dynamic call instruction> <function object location descriptor> <list of argument descriptors
with explicitly defined length>`

## 4. Other call-like instructions

There are instructions that are not host function calls technically since they do not correspond
to lagnuage's predefined functions and operators. Yet they are provided with a list of argument
descriptors of a predefined length in the same way as the host function calls. For example,
copy and move instructions each have exactly two argument descriptors &ndash; one for the source and
another for the destination (side note: the move instruction nullifies the source, not increasing
the number of references in case of moving a reference; the copy instruction keeps the source intact
and thus increases the number of references when copying a reference).

For the sake of symplicity we can use the host function call scheme for these call-like instructions
&ndash; and even consider zero-argument instructions as host function calls. Alternatively, we will
have a wider set of instruction code and use the following schema for call-like instructions:

`<call-like instruction>  <predefined number of argument descriptors>`

## 5. Argument descriptors

For starters, there are two kinds of argument descriptors &ndash; immediate arguments (for constant of basic
non-refernece types) and non-immediate arguments (for values stored at various run-time locations).
Considering the fact that there are also several types of run-time locations, it makes sense to have one
enumeraton of argument kinds that has a special value for immediate arguments and then several values one
per location type:

1. **Immediate arguments**: that kind of descriptor contains the base type constant value right in the descriptor.
We can use a variable length encoding here or use a 64-bit value always with NaNVM scheme of encoding
base value type within that value. From the flexibility point of view it makes sense to not take dependency
on NaNVM's scheme of encoding base values and use the benefit of compactness of a variable length encoding
scheme here.
2. **Caller's local values**: that is a kind of location descriptors referring to locations the caller
function's frame. We don't use this kind of descriptors for other frames in the caller chain, nor for the
"global frame" - only for locals of the immediate caller. Within that frame, locations are indexed by unsigned
integers starting from zero. One would say that these locations correspond one to one to named locals, but that
would prohibit a frame slot reuse optimization that the parser can implement, so we don't use this analogy.
3. **Caller's temporary values**: that is a kind of location used for caller's temporary values typically
produced dynamically "on the stack" when calculating expressions. These locations are zero-based indexes with
zero corresponding to the top of the stack and greater unsigned integer indexes corresponding to deeper stack
locations counting from the top of the stack. The VM might decide to combine function's frame of locals with
the stack of temporary values, but that is an implementation detail of that VM so other implementations can
use another approach, completely separating two location kinds.
4. **Captured values**: that kind of location is used when the user-defined caller function refers to value
names that are not locally defined in it, but rather belong to outer contexts. We cannot use a scheme that
decribes a value belonging to the frame "up in the caller chain" because, after being defined, a function
object can be detouched from the call chain context and then passed into another, different context where
the original caller chain references are not relevant anymore. So, when detecting a reference to an outer
context within a function body, the parser registers it as a captured value, and captured values are stored
in a devoted frame owned by the function object, and naturally that frame is separate from other localtion
kinds described here. As usually, withing that frame locations are indexed by unsigned integers.
5. **Caller's arguments** (questionable: see the next section, **discussion on caller's arguments**): that
kind of location is used when the caller passes its argument as an argument of the callee function. As in
the case of separate location kinds for caller's local values and caller's temporary values, it makes sense
to separate caller's arguments as yet another kind of a location. One reason for that is &ndash; in the case
of a dynamic user-defined function call the parser doesn't know how many arguments the callee expects; besides,
the callee might support a variable number of arguments (printf-style). Thus the VM cannot copy arguments to
predefined locations within the caller's local values stack (though in case of static calls that makes perfect
sense, so the parser can use the previosly described local values stack location kind, theoretically). As
usually, locations are unsigned integers with zero corresponding to the first argument and so on.

## Discussion on descriptor of callee's arguments and dynamic call instruction scheme

In JS, function parameters can be referred by names or as elements of `arguments` array. Thus for the sake of
simplicity we can decide to not have a special location kind for callee's arguments. Instead, in case of
a dynamic function call, VM always shapes `arguments` array object and passes it in the callee stack frame
&ndash at the predefined index (let's say zero). Static user-defined function calls do not need that, given
that if a function that could be treated by the parser as static, uses `arguments` in its body, cannot be
treated as static (losing correspondent optimizations specific static user-defined functions). Thus a static
user-defined function can use zero index in its frame for one of its locals.

With this approach, the dynamic function call instruction scheme looks like a call-like instruction with exactly
one argument descriptor that specifies the location of the function object (since VM's manipulation with the
argument array object reference placing at zero index of the caller function frame remains behind the scene):

`<dynamic call instruction> <function object location descriptor>




